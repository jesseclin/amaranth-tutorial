# 基本操作

> 注意：この章は単なる簡単な紹介です。アマランス言語ガイドの[演算子](https://amaranth-lang.org/docs/amaranth/latest/lang.html#operators)章では詳細に説明されています。

## ステートメント

Amaranth はPythonをハードウェアに変換しません。要するに、Amaranthを使用して書いているものはHDLロジック自体ではなく、HDLロジックの*ジェネレータ*です。したがって、1つの`Value`が別の値を取るようにしたい場合、`a = b`とは書きません。代わりに、等式を生成する`a`のメソッドを呼び出します：`a.eq(b)`。これはHDLの*ステートメント*として知られています。

ただし、多くの数学演算子はPythonでオーバーライド可能です。これらはPython関数への呼び出しに変換されるためです。そのため、例えば、Pythonの加算が関数呼び出しにオーバーライドできるので、`a.eq(b+1)`のように書くことができます。Amaranthの`Signal`クラスは、そのような演算子すべてに対してそれを行います。

### 直接翻訳可能なPython演算子のリスト

| Operator | Operation                | Notes                            |
| -------- | ------------------------ | -------------------------------- |
| `-`      | 算術否定      |
| `+`      | 加算                 |
| `-`      | 減算              |
| `*`      | 乗算           |
| `%`      | 剰余                  |
| `//`     | 除算                 | 整数除算、切り捨て。 |
| `<<`     | 左シフト               |
| `>>`     | 右シフト              | 以下を参照してください。効果的な算術右シフトです。 |
| `~`      | ビットごとの補数       |
| `&`      | ビットごとの論理積              |
| `\|`     | ビットごとの論理和               |
| `^`      | ビットごとの排他的論理和              |
| `==`     | 等号                 |
| `!=`     | 不等号               |
| `>`      | より大きい            |
| `>=`     | 以上 |
| `<`      | 未満                |
| `<=`     | 以下    |

Pythonの論理演算子（`not`、`and`、`or`）には翻訳可能なものがないことに注意してください。Amaranthの値をブール値として使用しようとすると、`Attempted to convert Amaranth value to Python boolean`というエラーが発生します。

右シフトは実質的に算術的であり、符号付きの値では符号ビットが存在し、符号なしの値では欠落している（または暗黙のうちにゼロ）場合があります。符号付きの値に右シフトを適用すると、シフトは正しく符号ビットを複製します。符号なしの値に適用される場合、シフトは論理的です。これを算術シフトと考えることもできますが、常に「欠落している」符号ビットがゼロであると考えることができます。符号なしの値に対して右シフト(`>>`)を行う場合、論理右シフトとして動作します。

### 操作が結果の幅に及ぼす影響

Pythonの整数は潜在的に無限のビット幅を持っています。この考え方に従って、信号に対する操作は、オペランドの幅と、それらが符号付き（2の補数で表される）かどうかに応じて、結果を保持するのに十分なビットを持つ結果を生成します。したがって、2つの符号なしの4ビット信号を加算すると、5ビットの信号が生成される必要があります。各オペランドの範囲は0から15までですので、結果の範囲は0から30です。これには5ビットが必要です。

```python
>>> from amaranth import Signal
>>> s1 = Signal(4)
>>> s2 = Signal(4)
>>> v = s1 + s2
>>> v.shape()
(width=5, signed=False)
>>>
```

同じことが、2つの5ビットの2の補数信号を加算する場合にも起こります。各オペランドの範囲は-16から+15ですので、結果の範囲は-32から30です。つまり、2つの5ビットの2の補数信号を加算すると、6ビットの2の補数信号が得られます。これは比較に影響を与える重要な点ですので、後でこれに対処する方法を見ていきます。

## 信号のマルチプレクシング

`Mux`は条件が真の場合に1つの信号を返し、それ以外の場合には他の信号を返します：

```python
y.eq(Mux(cond, x1, x2))
```

この場合、`cond`がtrueの場合、`y`は`x1`に設定され、そうでない場合は`x2`に設定されます。これはPythonの条件式`x1 if cond else x2`や他の言語の`cond ? x1 : x2`と同等です。

## ステートメントをドメインに配置する

ステートメントは、モジュールの組み合わせドメイン、またはモジュールのシーケンシャルドメイン（クロックドメイン）に書かれます。Verilogでの相当するものは、連続的な代入とクロック駆動の代入です。

したがって、モジュール`m`がある場合、`x`が常に`y+1`の値を取得するステートメントを次のように追加できます:

```python
m.d.comb += x.eq(y+1)
```

一方、正エッジでクロックされるクロックドメイン`sync`がある場合、次のようにして、`x`が`sync`のクロックの正エッジで`y+1`の値を取得するステートメントを追加できます:

```python
m.d.sync += x.eq(y+1)
```

## 複数のステートメントの追加

ドメインの`+=`演算子は、1つのステートメント、または複数のステートメントの配列を取ることができます。これは便利です:

```python
m.d.comb += [
    x.eq(y+1),
    z.eq(w+2),
]
```

## "オーバーライド"するステートメント

もしステートメントが同じ信号を設定する場合、2番目の設定が優先されます。例えば:

```python
m.d.comb += x.eq(y+1)
m.d.comb += x.eq(y+2)
```

この場合、`x` は `y+2` となります。

1つの信号は2つの異なるドメインで設定できないことを覚えておいてください。そのため、これはドライバー-ドライバーの競合を引き起こします:

```python
m.d.comb += x.eq(y+1)
m.d.sync += x.eq(y+2)
```
