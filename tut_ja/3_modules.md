# モジュール

> 注意：この章は単なる簡単な紹介です。Amaranth 言語ガイドの[モジュール](https://amaranth-lang.org/docs/amaranth/latest/lang.html#modules)章ではさらに詳細に説明されています。

*モジュール*とは、再利用可能なHDL（Hardware Description Language）コードの一部です。これは、チップの仕様書のようなものと考えてください。他のモジュールで必要なだけそのようなチップを使用できます。

## モジュールの基本構造

モジュールは、Amaranthの`Elaboratable`クラスから派生したPythonクラスを使用して便利に作成することができます。ここには、最小限の開始スケルトンが示されています。少し後に、モジュールにHDLコードをどのように配置するかについて見ていきます。

```python
from amaranth import Elaboratable, Module
from amaranth.build import Platform


class ThingBlock(Elaboratable):
    def __init__(self):
        pass

    def elaborate(self, platform: Platform) -> Module:
        m = Module()
        return m
```

## モジュールの展開

## モジュールをエラボレートする

エラボレーションとは、HDLコードをVerilogまたはRTLIL（レジスタ転送言語中間言語）表現に変換することを意味します。

トップレベルモジュールとそのすべてのサブモジュールをエラボレートするための最小限のメインファイルがここに示されています。再び、これらの多くはまもなく明確になります。

```python
from amaranth import ClockDomain, Module
from amaranth.cli import main

from thing_block import ThingBlock


if __name__ == "__main__":
    sync = ClockDomain()

    block = ThingBlock()

    m = Module()
    m.domains += sync
    m.submodules += block

    main(m, ports=[sync.clk, sync.rst])
```

上記で定義した`ThingBlock`がモジュールクラスであることに注意してください。また、`ThingBlock`のインスタンス（`block`）を含むトップレベルモジュール`m`を定義し、さらに以下で詳しく説明する他のいくつかの要素を含めています。

* `main(module, ports=[<ports>], platform="<platform>")`は、指定されたモジュールを再帰的に含む、与えられたモジュールをエラボレートします。すべての`elaborate()`メソッドは、その`platform`引数が与えられた`platform`に設定されます。これは`None`または特定のチップや開発ボードを表す`Platform`であることができます。エラボレーション可能なオブジェクトは、異なるプラットフォーム用に異なるロジックを作成することがあり、プラットフォーム経由で直接チップのピンにアクセスすることができます。
  

```sh
python3 elaborate_main.py generate -t [v|il|cc] > thing.[v|il|cc]
```

モジュールの生成は、すべてのサブモジュールを含む単一のファイルを生成します。

Verilogを理解するベンダーツールで作業する場合は、Verilog（`-t v`）を選択してください。また、yosysで作業する場合はRTLIL（`-t il`）を使用してください。CXXRTL（`-t cc`）向けにC++ファイルを出力することもできます。

## ドメイン

*ドメイン*とは、基本的にはロジック要素のグループ化です。モジュールを入出力を持つブラックボックスと考えると、任意の出力は1つのドメイン内で生成されます。1つ以上のドメインで出力を設定しようとすると、エラボレーション中に信号に複数のドライバーがあるというエラーが発生します。これを「ドライバー-ドライバーの競合」と呼びます。

`モジュール`には、組合せドメインと同期ドメインの2つのドメインが組み込まれています。

`モジュール`のドメインには、その`d`属性を介してアクセスできます。

### 組合せ

クロック要素を含まないロジックは*組合せ*と呼ばれ、単にロジック要素を組み合わせます。これは`モジュール`が含むドメインの1つです。常に`comb`という名前が付けられており、`m.d.comb`を介してアクセスできます。

### 同期

クロック要素を含むロジックは*同期*と呼ばれます。特定のクロックドメイン内のすべてのフリップフロップ（FF）が、クロックドメインのクロックに従って同期して変化するためです。また、各クロックドメインには、すべてのFFを特定の状態にリセットできるリセット信号があります。最後に、ドメインはそのクロック上のエッジを指定し、すべてのFFが変化するタイミングを決定します：正のエッジまたは負のエッジ。

特定のクロックドメインのエッジを使用してクロックされていないフリップフロップ（FF）は、そのクロックドメインに属することはできません。定義上、それらは異なるクロックとリセットを持ち、したがって異なるクロックドメインに属します。2つのクロックドメインでシグナルを設定しようとする試みは、ドライバー-ドライバーの競合を引き起こします。

一部のハードウェアは1つのクロックドメインのみをサポートしています。多くのFPGAは少なくとも2つのクロックドメインをサポートしています。

それ以外が指定されていない限り、`Module`には`sync`と呼ばれる1つの同期ドメインがあります。これは`m.d.sync`を介してアクセスできます。

### 追加のドメインの作成

もう一つの組合せドメインを作成する理由はありません。上記で述べたように、モジュールにはすでに1つの組合せドメインである`comb`が含まれています。

`ClockDomain("<domain-name>", clk_edge="<pos|neg>")`を使用して同期クロックドメインを作成できます。これにより、そのドメインのクロックとリセット信号が提供されます。デフォルトでは、ドメイン名は`sync`であり、クロックエッジは`pos`です。

モジュールにドメインを追加するには、次の構文を使用します： `m.domains += <clockdomain>`。たとえば、モジュール`m`に`clk`という名前のクロックドメインを追加するには：

```python
from amaranth import ClockDomain

m = Module()
m.domains += ClockDomain("clk")

m.d.clk += ... # "clk"クロックドメインに追加するロジック。
```

モジュール内のドメインには、その名前を使用してアクセスできます。したがって、`ClockDomain("myclk")`で作成されたドメインは、`m.d.myclk`または`m.d["myclk"]`を介してアクセスされます。

次のようにしてクロックとリセット信号を取得できます：

* `ClockSignal(domain="<domain>")`は、指定されたドメインのクロック信号を提供します。
* `ResetSignal(domain="<domain>")`は、指定されたドメインのリセット信号を提供します。

### ヒント：同じクロックを持つがエッジが異なるクロックドメイン

これは、単純に正のエッジ用の1つの`ClockDomain`を作成し、異なるドメイン名と`clk_edge="neg"`を持つ別の`ClockDomain`を作成することで行うことができます:

```python
pos = ClockDomain("pos")
neg = ClockDomain("neg", clk_edge="neg")
```

次に、正のドメインのクロックとリセット信号を負のドメインに割り当てます:

```python
neg.clk = pos.clk
neg.rst = pos.rst
```

そして、これらをモジュールに追加することができます。同じステートメントで複数のドメインをモジュールに追加することができます:

```python
m.domains += [pos, neg]
```

### ドメインへのアクセス

前述のように、モジュールはその`d`属性を介して自身のドメインにアクセスできます。デフォルトでは、同期ドメインがモジュールの`domains`属性に追加された場合、そのドメインへのアクセスがすべてのモジュールに提供されます。そのモジュールがドメインが追加されたモジュールのサブモジュールでなくても、すべてのモジュールがそのドメインにアクセスできます。これは、グローバルクロックドメインを持つハードウェアを扱う際に便利です。

```python
m = Module()
m2 = Module()

m.domains += ClockDomain("thing")
m.d.thing += # ロジック
m2.d.thing += # ロジック
```

`ClockDomain`の`local`という名前のパラメータを`True`に設定することで、このグローバルな伝播を明示的に抑制することができます。これにより、クロックは追加されたモジュールのドメインとそのサブモジュールにのみ存在するように強制されます。

```python
m = Module()
m2 = Module()

m.domains += ClockDomain("thing", local=True)
m.d.thing += # ロジック
m2.d.thing += # これは失敗します
```

## ポート

モジュール内のポートに相当するものは、公開属性です。次の例では、`a`と`data`は他のモジュールから公開されており、`b`は公開されていません。これは、`a`と`data`が他のPythonクラスに公開されているのと同じであり、`b`が公開されていないのと同じです。

```python
class ThingBlock(Elaboratable):
    def __init__(self):
        self.a = Signal()
        self.data = Signal(8)

    def elaborate(self, platform: str):
        m = Module()

        b = Signal()

        return m
```

## シグナルのリセット/デフォルト値

シグナルが*組合せ*ドメインで設定されている場合、シグナルのデフォルト値を指定できます。デフォルトでは、これはゼロですが、ゼロ以外の値にする場合は、シグナルを構築する際にコンストラクタの`reset`という名前のパラメータを設定してシグナルのデフォルト値を指定できます。たとえば、次のようにすると、デフォルトで`0x1000`に設定された16ビットの符号なしシグナル`self.x`が作成されます。

```python
self.x = Signal(unsigned(16), reset=0x1000)  # はい、「リセット」です。
```

同様に、シグナルが*同期*ドメインで設定されている場合、コンストラクタの`reset`という名前のパラメータを使用してそのリセット値を指定できます。デフォルトでは、リセット値はゼロです。

### リセットしないように明示的に設定する

同期シグナル（つまり、同期ドメインで設定されたシグナル）に対して、リセットシグナルでリセットされるべきでないことを指定できます。代わりに、電源投入時にのみ*初期値*を取得します。これは、コンストラクタの`reset_less`という名前のパラメータを`True`に設定することで行います:

```python
self.x = Signal(unsigned(16), reset=0x1000, reset_less=True)
```

これにより、最初に`0x1000`に設定された16ビットの符号なしシグナルが作成されますが、ドメインのリセットシグナルがアクティブ化されたときにその値にリセットされることはありません。

これは、シミュレーションや形式的検証中にリセットをアクティブにしたいが、一部のシグナルをリセットの「外側」に保持したい場合に特に有用です。たとえば、リセットを跨いでカウントを維持するサイクルカウンターなどがあります。

